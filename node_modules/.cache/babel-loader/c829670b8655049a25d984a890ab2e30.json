{"ast":null,"code":"'use strict';\n\nconst http2 = require('http2');\n\nconst {\n  Writable\n} = require('stream');\n\nconst {\n  Agent,\n  globalAgent\n} = require('./agent');\n\nconst IncomingMessage = require('./incoming-message');\n\nconst urlToOptions = require('./utils/url-to-options');\n\nconst proxyEvents = require('./utils/proxy-events');\n\nconst isRequestPseudoHeader = require('./utils/is-request-pseudo-header');\n\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_PROTOCOL,\n  ERR_HTTP_HEADERS_SENT,\n  ERR_INVALID_HTTP_TOKEN,\n  ERR_HTTP_INVALID_HEADER_VALUE,\n  ERR_INVALID_CHAR\n} = require('./utils/errors');\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_METHOD_CONNECT\n} = http2.constants;\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\nconst isValidHttpToken = /^[\\^`\\-\\w!#$%&*+.|~]+$/;\nconst isInvalidHeaderValue = /[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/;\n\nclass ClientRequest extends Writable {\n  constructor(input, options, callback) {\n    super({\n      autoDestroy: false\n    });\n    const hasInput = typeof input === 'string' || input instanceof URL;\n\n    if (hasInput) {\n      input = urlToOptions(input instanceof URL ? input : new URL(input));\n    }\n\n    if (typeof options === 'function' || options === undefined) {\n      // (options, callback)\n      callback = options;\n      options = hasInput ? input : { ...input\n      };\n    } else {\n      // (input, options, callback)\n      options = { ...input,\n        ...options\n      };\n    }\n\n    if (options.h2session) {\n      this[kSession] = options.h2session;\n    } else if (options.agent === false) {\n      this.agent = new Agent({\n        maxFreeSessions: 0\n      });\n    } else if (typeof options.agent === 'undefined' || options.agent === null) {\n      if (typeof options.createConnection === 'function') {\n        // This is a workaround - we don't have to create the session on our own.\n        this.agent = new Agent({\n          maxFreeSessions: 0\n        });\n        this.agent.createConnection = options.createConnection;\n      } else {\n        this.agent = globalAgent;\n      }\n    } else if (typeof options.agent.request === 'function') {\n      this.agent = options.agent;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);\n    }\n\n    if (options.protocol && options.protocol !== 'https:') {\n      throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');\n    }\n\n    const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;\n    const host = options.hostname || options.host || 'localhost'; // Don't enforce the origin via options. It may be changed in an Agent.\n\n    delete options.hostname;\n    delete options.host;\n    delete options.port;\n    const {\n      timeout\n    } = options;\n    options.timeout = undefined;\n    this[kHeaders] = Object.create(null);\n    this[kJobs] = [];\n    this.socket = null;\n    this.connection = null;\n    this.method = options.method || 'GET';\n    this.path = options.path;\n    this.res = null;\n    this.aborted = false;\n    this.reusedSocket = false;\n\n    if (options.headers) {\n      for (const [header, value] of Object.entries(options.headers)) {\n        this.setHeader(header, value);\n      }\n    }\n\n    if (options.auth && !('authorization' in this[kHeaders])) {\n      this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n    }\n\n    options.session = options.tlsSession;\n    options.path = options.socketPath;\n    this[kOptions] = options; // Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\n    if (port === 443) {\n      this[kOrigin] = `https://${host}`;\n\n      if (!(':authority' in this[kHeaders])) {\n        this[kHeaders][':authority'] = host;\n      }\n    } else {\n      this[kOrigin] = `https://${host}:${port}`;\n\n      if (!(':authority' in this[kHeaders])) {\n        this[kHeaders][':authority'] = `${host}:${port}`;\n      }\n    }\n\n    if (timeout) {\n      this.setTimeout(timeout);\n    }\n\n    if (callback) {\n      this.once('response', callback);\n    }\n\n    this[kFlushedHeaders] = false;\n  }\n\n  get method() {\n    return this[kHeaders][HTTP2_HEADER_METHOD];\n  }\n\n  set method(value) {\n    if (value) {\n      this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n    }\n  }\n\n  get path() {\n    return this[kHeaders][HTTP2_HEADER_PATH];\n  }\n\n  set path(value) {\n    if (value) {\n      this[kHeaders][HTTP2_HEADER_PATH] = value;\n    }\n  }\n\n  get _mustNotHaveABody() {\n    return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n  }\n\n  _write(chunk, encoding, callback) {\n    // https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n    if (this._mustNotHaveABody) {\n      callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n      /* istanbul ignore next: Node.js 12 throws directly */\n\n      return;\n    }\n\n    this.flushHeaders();\n\n    const callWrite = () => this._request.write(chunk, encoding, callback);\n\n    if (this._request) {\n      callWrite();\n    } else {\n      this[kJobs].push(callWrite);\n    }\n  }\n\n  _final(callback) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this.flushHeaders();\n\n    const callEnd = () => {\n      // For GET, HEAD and DELETE\n      if (this._mustNotHaveABody) {\n        callback();\n        return;\n      }\n\n      this._request.end(callback);\n    };\n\n    if (this._request) {\n      callEnd();\n    } else {\n      this[kJobs].push(callEnd);\n    }\n  }\n\n  abort() {\n    if (this.res && this.res.complete) {\n      return;\n    }\n\n    if (!this.aborted) {\n      process.nextTick(() => this.emit('abort'));\n    }\n\n    this.aborted = true;\n    this.destroy();\n  }\n\n  _destroy(error, callback) {\n    if (this.res) {\n      this.res._dump();\n    }\n\n    if (this._request) {\n      this._request.destroy();\n    }\n\n    callback(error);\n  }\n\n  async flushHeaders() {\n    var _this = this;\n\n    if (this[kFlushedHeaders] || this.destroyed) {\n      return;\n    }\n\n    this[kFlushedHeaders] = true;\n    const isConnectMethod = this.method === HTTP2_METHOD_CONNECT; // The real magic is here\n\n    const onStream = stream => {\n      this._request = stream;\n\n      if (this.destroyed) {\n        stream.destroy();\n        return;\n      } // Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\n\n      if (!isConnectMethod) {\n        proxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);\n      } // Wait for the `finish` event. We don't want to emit the `response` event\n      // before `request.end()` is called.\n\n\n      const waitForEnd = fn => {\n        return function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          if (!_this.writable && !_this.destroyed) {\n            fn(...args);\n          } else {\n            _this.once('finish', () => {\n              fn(...args);\n            });\n          }\n        };\n      }; // This event tells we are ready to listen for the data.\n\n\n      stream.once('response', waitForEnd((headers, flags, rawHeaders) => {\n        // If we were to emit raw request stream, it would be as fast as the native approach.\n        // Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n        const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n        this.res = response;\n        response.req = this;\n        response.statusCode = headers[HTTP2_HEADER_STATUS];\n        response.headers = headers;\n        response.rawHeaders = rawHeaders;\n        response.once('end', () => {\n          if (this.aborted) {\n            response.aborted = true;\n            response.emit('aborted');\n          } else {\n            response.complete = true; // Has no effect, just be consistent with the Node.js behavior\n\n            response.socket = null;\n            response.connection = null;\n          }\n        });\n\n        if (isConnectMethod) {\n          response.upgrade = true; // The HTTP1 API says the socket is detached here,\n          // but we can't do that so we pass the original HTTP2 request.\n\n          if (this.emit('connect', response, stream, Buffer.alloc(0))) {\n            this.emit('close');\n          } else {\n            // No listeners attached, destroy the original request.\n            stream.destroy();\n          }\n        } else {\n          // Forwards data\n          stream.on('data', chunk => {\n            if (!response._dumped && !response.push(chunk)) {\n              stream.pause();\n            }\n          });\n          stream.once('end', () => {\n            response.push(null);\n          });\n\n          if (!this.emit('response', response)) {\n            // No listeners attached, dump the response.\n            response._dump();\n          }\n        }\n      })); // Emits `information` event\n\n      stream.once('headers', waitForEnd(headers => this.emit('information', {\n        statusCode: headers[HTTP2_HEADER_STATUS]\n      })));\n      stream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {\n        const {\n          res\n        } = this; // Assigns trailers to the response object.\n\n        res.trailers = trailers;\n        res.rawTrailers = rawTrailers;\n      }));\n      const {\n        socket\n      } = stream.session;\n      this.socket = socket;\n      this.connection = socket;\n\n      for (const job of this[kJobs]) {\n        job();\n      }\n\n      this.emit('socket', this.socket);\n    }; // Makes a HTTP2 request\n\n\n    if (this[kSession]) {\n      try {\n        onStream(this[kSession].request(this[kHeaders]));\n      } catch (error) {\n        this.emit('error', error);\n      }\n    } else {\n      this.reusedSocket = true;\n\n      try {\n        onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n  }\n\n  getHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    return this[kHeaders][name.toLowerCase()];\n  }\n\n  get headersSent() {\n    return this[kFlushedHeaders];\n  }\n\n  removeHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    if (this.headersSent) {\n      throw new ERR_HTTP_HEADERS_SENT('remove');\n    }\n\n    delete this[kHeaders][name.toLowerCase()];\n  }\n\n  setHeader(name, value) {\n    if (this.headersSent) {\n      throw new ERR_HTTP_HEADERS_SENT('set');\n    }\n\n    if (typeof name !== 'string' || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {\n      throw new ERR_INVALID_HTTP_TOKEN('Header name', name);\n    }\n\n    if (typeof value === 'undefined') {\n      throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n    }\n\n    if (isInvalidHeaderValue.test(value)) {\n      throw new ERR_INVALID_CHAR('header content', name);\n    }\n\n    this[kHeaders][name.toLowerCase()] = value;\n  }\n\n  setNoDelay() {// HTTP2 sockets cannot be malformed, do nothing.\n  }\n\n  setSocketKeepAlive() {// HTTP2 sockets cannot be malformed, do nothing.\n  }\n\n  setTimeout(ms, callback) {\n    const applyTimeout = () => this._request.setTimeout(ms, callback);\n\n    if (this._request) {\n      applyTimeout();\n    } else {\n      this[kJobs].push(applyTimeout);\n    }\n\n    return this;\n  }\n\n  get maxHeadersCount() {\n    if (!this.destroyed && this._request) {\n      return this._request.session.localSettings.maxHeaderListSize;\n    }\n\n    return undefined;\n  }\n\n  set maxHeadersCount(_value) {// Updating HTTP2 settings would affect all requests, do nothing.\n  }\n\n}\n\nmodule.exports = ClientRequest;","map":{"version":3,"names":["http2","require","Writable","Agent","globalAgent","IncomingMessage","urlToOptions","proxyEvents","isRequestPseudoHeader","ERR_INVALID_ARG_TYPE","ERR_INVALID_PROTOCOL","ERR_HTTP_HEADERS_SENT","ERR_INVALID_HTTP_TOKEN","ERR_HTTP_INVALID_HEADER_VALUE","ERR_INVALID_CHAR","HTTP2_HEADER_STATUS","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_METHOD_CONNECT","constants","kHeaders","Symbol","kOrigin","kSession","kOptions","kFlushedHeaders","kJobs","isValidHttpToken","isInvalidHeaderValue","ClientRequest","constructor","input","options","callback","autoDestroy","hasInput","URL","undefined","h2session","agent","maxFreeSessions","createConnection","request","protocol","port","defaultPort","host","hostname","timeout","Object","create","socket","connection","method","path","res","aborted","reusedSocket","headers","header","value","entries","setHeader","auth","authorization","Buffer","from","toString","session","tlsSession","socketPath","setTimeout","once","toUpperCase","_mustNotHaveABody","_write","chunk","encoding","Error","flushHeaders","callWrite","_request","write","push","_final","destroyed","callEnd","end","abort","complete","process","nextTick","emit","destroy","_destroy","error","_dump","isConnectMethod","onStream","stream","waitForEnd","fn","args","writable","flags","rawHeaders","response","readableHighWaterMark","req","statusCode","upgrade","alloc","on","_dumped","pause","trailers","rawTrailers","job","getHeader","name","toLowerCase","headersSent","removeHeader","test","setNoDelay","setSocketKeepAlive","ms","applyTimeout","maxHeadersCount","localSettings","maxHeaderListSize","_value","module","exports"],"sources":["C:/Users/hamzu/Desktop/React/React projects/react-store/node_modules/http2-wrapper/source/client-request.js"],"sourcesContent":["'use strict';\nconst http2 = require('http2');\nconst {Writable} = require('stream');\nconst {Agent, globalAgent} = require('./agent');\nconst IncomingMessage = require('./incoming-message');\nconst urlToOptions = require('./utils/url-to-options');\nconst proxyEvents = require('./utils/proxy-events');\nconst isRequestPseudoHeader = require('./utils/is-request-pseudo-header');\nconst {\n\tERR_INVALID_ARG_TYPE,\n\tERR_INVALID_PROTOCOL,\n\tERR_HTTP_HEADERS_SENT,\n\tERR_INVALID_HTTP_TOKEN,\n\tERR_HTTP_INVALID_HEADER_VALUE,\n\tERR_INVALID_CHAR\n} = require('./utils/errors');\n\nconst {\n\tHTTP2_HEADER_STATUS,\n\tHTTP2_HEADER_METHOD,\n\tHTTP2_HEADER_PATH,\n\tHTTP2_METHOD_CONNECT\n} = http2.constants;\n\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\n\nconst isValidHttpToken = /^[\\^`\\-\\w!#$%&*+.|~]+$/;\nconst isInvalidHeaderValue = /[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/;\n\nclass ClientRequest extends Writable {\n\tconstructor(input, options, callback) {\n\t\tsuper({\n\t\t\tautoDestroy: false\n\t\t});\n\n\t\tconst hasInput = typeof input === 'string' || input instanceof URL;\n\t\tif (hasInput) {\n\t\t\tinput = urlToOptions(input instanceof URL ? input : new URL(input));\n\t\t}\n\n\t\tif (typeof options === 'function' || options === undefined) {\n\t\t\t// (options, callback)\n\t\t\tcallback = options;\n\t\t\toptions = hasInput ? input : {...input};\n\t\t} else {\n\t\t\t// (input, options, callback)\n\t\t\toptions = {...input, ...options};\n\t\t}\n\n\t\tif (options.h2session) {\n\t\t\tthis[kSession] = options.h2session;\n\t\t} else if (options.agent === false) {\n\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t} else if (typeof options.agent === 'undefined' || options.agent === null) {\n\t\t\tif (typeof options.createConnection === 'function') {\n\t\t\t\t// This is a workaround - we don't have to create the session on our own.\n\t\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t\t\tthis.agent.createConnection = options.createConnection;\n\t\t\t} else {\n\t\t\t\tthis.agent = globalAgent;\n\t\t\t}\n\t\t} else if (typeof options.agent.request === 'function') {\n\t\t\tthis.agent = options.agent;\n\t\t} else {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);\n\t\t}\n\n\t\tif (options.protocol && options.protocol !== 'https:') {\n\t\t\tthrow new ERR_INVALID_PROTOCOL(options.protocol, 'https:');\n\t\t}\n\n\t\tconst port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;\n\t\tconst host = options.hostname || options.host || 'localhost';\n\n\t\t// Don't enforce the origin via options. It may be changed in an Agent.\n\t\tdelete options.hostname;\n\t\tdelete options.host;\n\t\tdelete options.port;\n\n\t\tconst {timeout} = options;\n\t\toptions.timeout = undefined;\n\n\t\tthis[kHeaders] = Object.create(null);\n\t\tthis[kJobs] = [];\n\n\t\tthis.socket = null;\n\t\tthis.connection = null;\n\n\t\tthis.method = options.method || 'GET';\n\t\tthis.path = options.path;\n\n\t\tthis.res = null;\n\t\tthis.aborted = false;\n\t\tthis.reusedSocket = false;\n\n\t\tif (options.headers) {\n\t\t\tfor (const [header, value] of Object.entries(options.headers)) {\n\t\t\t\tthis.setHeader(header, value);\n\t\t\t}\n\t\t}\n\n\t\tif (options.auth && !('authorization' in this[kHeaders])) {\n\t\t\tthis[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n\t\t}\n\n\t\toptions.session = options.tlsSession;\n\t\toptions.path = options.socketPath;\n\n\t\tthis[kOptions] = options;\n\n\t\t// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\t\tif (port === 443) {\n\t\t\tthis[kOrigin] = `https://${host}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = host;\n\t\t\t}\n\t\t} else {\n\t\t\tthis[kOrigin] = `https://${host}:${port}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = `${host}:${port}`;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tthis.setTimeout(timeout);\n\t\t}\n\n\t\tif (callback) {\n\t\t\tthis.once('response', callback);\n\t\t}\n\n\t\tthis[kFlushedHeaders] = false;\n\t}\n\n\tget method() {\n\t\treturn this[kHeaders][HTTP2_HEADER_METHOD];\n\t}\n\n\tset method(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn this[kHeaders][HTTP2_HEADER_PATH];\n\t}\n\n\tset path(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_PATH] = value;\n\t\t}\n\t}\n\n\tget _mustNotHaveABody() {\n\t\treturn this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n\t}\n\n\t_write(chunk, encoding, callback) {\n\t\t// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n\t\tif (this._mustNotHaveABody) {\n\t\t\tcallback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n\t\t\t/* istanbul ignore next: Node.js 12 throws directly */\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callWrite = () => this._request.write(chunk, encoding, callback);\n\t\tif (this._request) {\n\t\t\tcallWrite();\n\t\t} else {\n\t\t\tthis[kJobs].push(callWrite);\n\t\t}\n\t}\n\n\t_final(callback) {\n\t\tif (this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callEnd = () => {\n\t\t\t// For GET, HEAD and DELETE\n\t\t\tif (this._mustNotHaveABody) {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._request.end(callback);\n\t\t};\n\n\t\tif (this._request) {\n\t\t\tcallEnd();\n\t\t} else {\n\t\t\tthis[kJobs].push(callEnd);\n\t\t}\n\t}\n\n\tabort() {\n\t\tif (this.res && this.res.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.aborted) {\n\t\t\tprocess.nextTick(() => this.emit('abort'));\n\t\t}\n\n\t\tthis.aborted = true;\n\n\t\tthis.destroy();\n\t}\n\n\t_destroy(error, callback) {\n\t\tif (this.res) {\n\t\t\tthis.res._dump();\n\t\t}\n\n\t\tif (this._request) {\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tcallback(error);\n\t}\n\n\tasync flushHeaders() {\n\t\tif (this[kFlushedHeaders] || this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis[kFlushedHeaders] = true;\n\n\t\tconst isConnectMethod = this.method === HTTP2_METHOD_CONNECT;\n\n\t\t// The real magic is here\n\t\tconst onStream = stream => {\n\t\t\tthis._request = stream;\n\n\t\t\tif (this.destroyed) {\n\t\t\t\tstream.destroy();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\t\t\tif (!isConnectMethod) {\n\t\t\t\tproxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);\n\t\t\t}\n\n\t\t\t// Wait for the `finish` event. We don't want to emit the `response` event\n\t\t\t// before `request.end()` is called.\n\t\t\tconst waitForEnd = fn => {\n\t\t\t\treturn (...args) => {\n\t\t\t\t\tif (!this.writable && !this.destroyed) {\n\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.once('finish', () => {\n\t\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// This event tells we are ready to listen for the data.\n\t\t\tstream.once('response', waitForEnd((headers, flags, rawHeaders) => {\n\t\t\t\t// If we were to emit raw request stream, it would be as fast as the native approach.\n\t\t\t\t// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n\t\t\t\tconst response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n\t\t\t\tthis.res = response;\n\n\t\t\t\tresponse.req = this;\n\t\t\t\tresponse.statusCode = headers[HTTP2_HEADER_STATUS];\n\t\t\t\tresponse.headers = headers;\n\t\t\t\tresponse.rawHeaders = rawHeaders;\n\n\t\t\t\tresponse.once('end', () => {\n\t\t\t\t\tif (this.aborted) {\n\t\t\t\t\t\tresponse.aborted = true;\n\t\t\t\t\t\tresponse.emit('aborted');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.complete = true;\n\n\t\t\t\t\t\t// Has no effect, just be consistent with the Node.js behavior\n\t\t\t\t\t\tresponse.socket = null;\n\t\t\t\t\t\tresponse.connection = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (isConnectMethod) {\n\t\t\t\t\tresponse.upgrade = true;\n\n\t\t\t\t\t// The HTTP1 API says the socket is detached here,\n\t\t\t\t\t// but we can't do that so we pass the original HTTP2 request.\n\t\t\t\t\tif (this.emit('connect', response, stream, Buffer.alloc(0))) {\n\t\t\t\t\t\tthis.emit('close');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No listeners attached, destroy the original request.\n\t\t\t\t\t\tstream.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Forwards data\n\t\t\t\t\tstream.on('data', chunk => {\n\t\t\t\t\t\tif (!response._dumped && !response.push(chunk)) {\n\t\t\t\t\t\t\tstream.pause();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.once('end', () => {\n\t\t\t\t\t\tresponse.push(null);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!this.emit('response', response)) {\n\t\t\t\t\t\t// No listeners attached, dump the response.\n\t\t\t\t\t\tresponse._dump();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Emits `information` event\n\t\t\tstream.once('headers', waitForEnd(\n\t\t\t\theaders => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})\n\t\t\t));\n\n\t\t\tstream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {\n\t\t\t\tconst {res} = this;\n\n\t\t\t\t// Assigns trailers to the response object.\n\t\t\t\tres.trailers = trailers;\n\t\t\t\tres.rawTrailers = rawTrailers;\n\t\t\t}));\n\n\t\t\tconst {socket} = stream.session;\n\t\t\tthis.socket = socket;\n\t\t\tthis.connection = socket;\n\n\t\t\tfor (const job of this[kJobs]) {\n\t\t\t\tjob();\n\t\t\t}\n\n\t\t\tthis.emit('socket', this.socket);\n\t\t};\n\n\t\t// Makes a HTTP2 request\n\t\tif (this[kSession]) {\n\t\t\ttry {\n\t\t\t\tonStream(this[kSession].request(this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.reusedSocket = true;\n\n\t\t\ttry {\n\t\t\t\tonStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\treturn this[kHeaders][name.toLowerCase()];\n\t}\n\n\tget headersSent() {\n\t\treturn this[kFlushedHeaders];\n\t}\n\n\tremoveHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('remove');\n\t\t}\n\n\t\tdelete this[kHeaders][name.toLowerCase()];\n\t}\n\n\tsetHeader(name, value) {\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('set');\n\t\t}\n\n\t\tif (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {\n\t\t\tthrow new ERR_INVALID_HTTP_TOKEN('Header name', name);\n\t\t}\n\n\t\tif (typeof value === 'undefined') {\n\t\t\tthrow new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n\t\t}\n\n\t\tif (isInvalidHeaderValue.test(value)) {\n\t\t\tthrow new ERR_INVALID_CHAR('header content', name);\n\t\t}\n\n\t\tthis[kHeaders][name.toLowerCase()] = value;\n\t}\n\n\tsetNoDelay() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetSocketKeepAlive() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tconst applyTimeout = () => this._request.setTimeout(ms, callback);\n\n\t\tif (this._request) {\n\t\t\tapplyTimeout();\n\t\t} else {\n\t\t\tthis[kJobs].push(applyTimeout);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tget maxHeadersCount() {\n\t\tif (!this.destroyed && this._request) {\n\t\t\treturn this._request.session.localSettings.maxHeaderListSize;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tset maxHeadersCount(_value) {\n\t\t// Updating HTTP2 settings would affect all requests, do nothing.\n\t}\n}\n\nmodule.exports = ClientRequest;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}