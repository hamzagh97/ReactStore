{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst tls = require('tls');\n\nconst http2 = require('http2');\n\nconst QuickLRU = require('quick-lru');\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst nameKeys = [// `http2.connect()` options\n'maxDeflateDynamicTableSize', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy', // `tls.connect()` options\n'localAddress', 'path', 'rejectUnauthorized', 'minDHSize', // `tls.createSecureContext()` options\n'ca', 'cert', 'clientCertEngine', 'ciphers', 'key', 'pfx', 'servername', 'minVersion', 'maxVersion', 'secureProtocol', 'crl', 'honorCipherOrder', 'ecdhCurve', 'dhparam', 'secureOptions', 'sessionIdContext'];\n\nconst getSortedIndex = (array, value, compare) => {\n  let low = 0;\n  let high = array.length;\n\n  while (low < high) {\n    const mid = low + high >>> 1;\n    /* istanbul ignore next */\n\n    if (compare(array[mid], value)) {\n      // This never gets called because we use descending sort. Better to have this anyway.\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return low;\n};\n\nconst compareSessions = (a, b) => {\n  return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n}; // See https://tools.ietf.org/html/rfc8336\n\n\nconst closeCoveredSessions = (where, session) => {\n  // Clients SHOULD NOT emit new requests on any connection whose Origin\n  // Set is a proper subset of another connection's Origin Set, and they\n  // SHOULD close it once all outstanding requests are satisfied.\n  for (const coveredSession of where) {\n    if ( // The set is a proper subset when its length is less than the other set.\n    coveredSession[kOriginSet].length < session[kOriginSet].length && // And the other set includes all elements of the subset.\n    coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && // Makes sure that the session can handle all requests from the covered session.\n    coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n      // This allows pending requests to finish and prevents making new requests.\n      gracefullyClose(coveredSession);\n    }\n  }\n}; // This is basically inverted `closeCoveredSessions(...)`.\n\n\nconst closeSessionIfCovered = (where, coveredSession) => {\n  for (const session of where) {\n    if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n      gracefullyClose(coveredSession);\n    }\n  }\n};\n\nconst getSessions = _ref => {\n  let {\n    agent,\n    isFree\n  } = _ref;\n  const result = {}; // eslint-disable-next-line guard-for-in\n\n  for (const normalizedOptions in agent.sessions) {\n    const sessions = agent.sessions[normalizedOptions];\n    const filtered = sessions.filter(session => {\n      const result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n      return isFree ? result : !result;\n    });\n\n    if (filtered.length !== 0) {\n      result[normalizedOptions] = filtered;\n    }\n  }\n\n  return result;\n};\n\nconst gracefullyClose = session => {\n  session[kGracefullyClosing] = true;\n\n  if (session[kCurrentStreamsCount] === 0) {\n    session.close();\n  }\n};\n\nclass Agent extends EventEmitter {\n  constructor() {\n    let {\n      timeout = 60000,\n      maxSessions = Infinity,\n      maxFreeSessions = 10,\n      maxCachedTlsSessions = 100\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(); // A session is considered busy when its current streams count\n    // is equal to or greater than the `maxConcurrentStreams` value.\n    // A session is considered free when its current streams count\n    // is less than the `maxConcurrentStreams` value.\n    // SESSIONS[NORMALIZED_OPTIONS] = [];\n\n    this.sessions = {}; // The queue for creating new sessions. It looks like this:\n    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n    //\n    // The entry function has `listeners`, `completed` and `destroyed` properties.\n    // `listeners` is an array of objects containing `resolve` and `reject` functions.\n    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\n    this.queue = {}; // Each session will use this timeout value.\n\n    this.timeout = timeout; // Max sessions in total\n\n    this.maxSessions = maxSessions; // Max free sessions in total\n    // TODO: decreasing `maxFreeSessions` should close some sessions\n\n    this.maxFreeSessions = maxFreeSessions;\n    this._freeSessionsCount = 0;\n    this._sessionsCount = 0; // We don't support push streams by default.\n\n    this.settings = {\n      enablePush: false\n    }; // Reusing TLS sessions increases performance.\n\n    this.tlsSessionCache = new QuickLRU({\n      maxSize: maxCachedTlsSessions\n    });\n  }\n\n  static normalizeOrigin(url, servername) {\n    if (typeof url === 'string') {\n      url = new URL(url);\n    }\n\n    if (servername && url.hostname !== servername) {\n      url.hostname = servername;\n    }\n\n    return url.origin;\n  }\n\n  normalizeOptions(options) {\n    let normalized = '';\n\n    if (options) {\n      for (const key of nameKeys) {\n        if (options[key]) {\n          normalized += `:${options[key]}`;\n        }\n      }\n    }\n\n    return normalized;\n  }\n\n  _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n    if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n      return;\n    }\n\n    const item = this.queue[normalizedOptions][normalizedOrigin]; // The entry function can be run only once.\n    // BUG: The session may be never created when:\n    // - the first condition is false AND\n    // - this function is never called with the same arguments in the future.\n\n    if (this._sessionsCount < this.maxSessions && !item.completed) {\n      item.completed = true;\n      item();\n    }\n  }\n\n  getSession(origin, options, listeners) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(listeners)) {\n        listeners = [...listeners]; // Resolve the current promise ASAP, we're just moving the listeners.\n        // They will be executed at a different time.\n\n        resolve();\n      } else {\n        listeners = [{\n          resolve,\n          reject\n        }];\n      }\n\n      const normalizedOptions = this.normalizeOptions(options);\n      const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n      if (normalizedOrigin === undefined) {\n        for (const {\n          reject\n        } of listeners) {\n          reject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n        }\n\n        return;\n      }\n\n      if (normalizedOptions in this.sessions) {\n        const sessions = this.sessions[normalizedOptions];\n        let maxConcurrentStreams = -1;\n        let currentStreamsCount = -1;\n        let optimalSession; // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n        // Additionally, we are looking for session which has biggest current pending streams count.\n\n        for (const session of sessions) {\n          const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n          if (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n            break;\n          }\n\n          if (session[kOriginSet].includes(normalizedOrigin)) {\n            const sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n            if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || // Unfortunately the `close` event isn't called immediately,\n            // so `session.destroyed` is `true`, but `session.closed` is `false`.\n            session.destroyed) {\n              continue;\n            } // We only need set this once.\n\n\n            if (!optimalSession) {\n              maxConcurrentStreams = sessionMaxConcurrentStreams;\n            } // We're looking for the session which has biggest current pending stream count,\n            // in order to minimalize the amount of active sessions.\n\n\n            if (sessionCurrentStreamsCount > currentStreamsCount) {\n              optimalSession = session;\n              currentStreamsCount = sessionCurrentStreamsCount;\n            }\n          }\n        }\n\n        if (optimalSession) {\n          /* istanbul ignore next: safety check */\n          if (listeners.length !== 1) {\n            for (const {\n              reject\n            } of listeners) {\n              const error = new Error(`Expected the length of listeners to be 1, got ${listeners.length}.\\n` + 'Please report this to https://github.com/szmarczak/http2-wrapper/');\n              reject(error);\n            }\n\n            return;\n          }\n\n          listeners[0].resolve(optimalSession);\n          return;\n        }\n      }\n\n      if (normalizedOptions in this.queue) {\n        if (normalizedOrigin in this.queue[normalizedOptions]) {\n          // There's already an item in the queue, just attach ourselves to it.\n          this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners); // This shouldn't be executed here.\n          // See the comment inside _tryToCreateNewSession.\n\n          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\n          return;\n        }\n      } else {\n        this.queue[normalizedOptions] = {};\n      } // The entry must be removed from the queue IMMEDIATELY when:\n      // 1. the session connects successfully,\n      // 2. an error occurs.\n\n\n      const removeFromQueue = () => {\n        // Our entry can be replaced. We cannot remove the new one.\n        if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n          delete this.queue[normalizedOptions][normalizedOrigin];\n\n          if (Object.keys(this.queue[normalizedOptions]).length === 0) {\n            delete this.queue[normalizedOptions];\n          }\n        }\n      }; // The main logic is here\n\n\n      const entry = () => {\n        const name = `${normalizedOrigin}:${normalizedOptions}`;\n        let receivedSettings = false;\n\n        try {\n          const session = http2.connect(origin, {\n            createConnection: this.createConnection,\n            settings: this.settings,\n            session: this.tlsSessionCache.get(name),\n            ...options\n          });\n          session[kCurrentStreamsCount] = 0;\n          session[kGracefullyClosing] = false;\n\n          const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n          let wasFree = true;\n          session.socket.once('session', tlsSession => {\n            this.tlsSessionCache.set(name, tlsSession);\n          });\n          session.once('error', error => {\n            // Listeners are empty when the session successfully connected.\n            for (const {\n              reject\n            } of listeners) {\n              reject(error);\n            } // The connection got broken, purge the cache.\n\n\n            this.tlsSessionCache.delete(name);\n          });\n          session.setTimeout(this.timeout, () => {\n            // Terminates all streams owned by this session.\n            // TODO: Maybe the streams should have a \"Session timed out\" error?\n            session.destroy();\n          });\n          session.once('close', () => {\n            if (receivedSettings) {\n              // 1. If it wasn't free then no need to decrease because\n              //    it has been decreased already in session.request().\n              // 2. `stream.once('close')` won't increment the count\n              //    because the session is already closed.\n              if (wasFree) {\n                this._freeSessionsCount--;\n              }\n\n              this._sessionsCount--; // This cannot be moved to the stream logic,\n              // because there may be a session that hadn't made a single request.\n\n              const where = this.sessions[normalizedOptions];\n              where.splice(where.indexOf(session), 1);\n\n              if (where.length === 0) {\n                delete this.sessions[normalizedOptions];\n              }\n            } else {\n              // Broken connection\n              const error = new Error('Session closed without receiving a SETTINGS frame');\n              error.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n              for (const {\n                reject\n              } of listeners) {\n                reject(error);\n              }\n\n              removeFromQueue();\n            } // There may be another session awaiting.\n\n\n            this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n          }); // Iterates over the queue and processes listeners.\n\n          const processListeners = () => {\n            if (!(normalizedOptions in this.queue) || !isFree()) {\n              return;\n            }\n\n            for (const origin of session[kOriginSet]) {\n              if (origin in this.queue[normalizedOptions]) {\n                const {\n                  listeners\n                } = this.queue[normalizedOptions][origin]; // Prevents session overloading.\n\n                while (listeners.length !== 0 && isFree()) {\n                  // We assume `resolve(...)` calls `request(...)` *directly*,\n                  // otherwise the session will get overloaded.\n                  listeners.shift().resolve(session);\n                }\n\n                const where = this.queue[normalizedOptions];\n\n                if (where[origin].listeners.length === 0) {\n                  delete where[origin];\n\n                  if (Object.keys(where).length === 0) {\n                    delete this.queue[normalizedOptions];\n                    break;\n                  }\n                } // We're no longer free, no point in continuing.\n\n\n                if (!isFree()) {\n                  break;\n                }\n              }\n            }\n          }; // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\n\n          session.on('origin', () => {\n            session[kOriginSet] = session.originSet;\n\n            if (!isFree()) {\n              // The session is full.\n              return;\n            }\n\n            processListeners(); // Close covered sessions (if possible).\n\n            closeCoveredSessions(this.sessions[normalizedOptions], session);\n          });\n          session.once('remoteSettings', () => {\n            // Fix Node.js bug preventing the process from exiting\n            session.ref();\n            session.unref();\n            this._sessionsCount++; // The Agent could have been destroyed already.\n\n            if (entry.destroyed) {\n              const error = new Error('Agent has been destroyed');\n\n              for (const listener of listeners) {\n                listener.reject(error);\n              }\n\n              session.destroy();\n              return;\n            }\n\n            session[kOriginSet] = session.originSet;\n            {\n              const where = this.sessions;\n\n              if (normalizedOptions in where) {\n                const sessions = where[normalizedOptions];\n                sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n              } else {\n                where[normalizedOptions] = [session];\n              }\n            }\n            this._freeSessionsCount += 1;\n            receivedSettings = true;\n            this.emit('session', session);\n            processListeners();\n            removeFromQueue(); // TODO: Close last recently used (or least used?) session\n\n            if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n              session.close();\n            } // Check if we haven't managed to execute all listeners.\n\n\n            if (listeners.length !== 0) {\n              // Request for a new session with predefined listeners.\n              this.getSession(normalizedOrigin, options, listeners);\n              listeners.length = 0;\n            } // `session.remoteSettings.maxConcurrentStreams` might get increased\n\n\n            session.on('remoteSettings', () => {\n              processListeners(); // In case the Origin Set changes\n\n              closeCoveredSessions(this.sessions[normalizedOptions], session);\n            });\n          }); // Shim `session.request()` in order to catch all streams\n\n          session[kRequest] = session.request;\n\n          session.request = (headers, streamOptions) => {\n            if (session[kGracefullyClosing]) {\n              throw new Error('The session is gracefully closing. No new streams are allowed.');\n            }\n\n            const stream = session[kRequest](headers, streamOptions); // The process won't exit until the session is closed or all requests are gone.\n\n            session.ref();\n            ++session[kCurrentStreamsCount];\n\n            if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n              this._freeSessionsCount--;\n            }\n\n            stream.once('close', () => {\n              wasFree = isFree();\n              --session[kCurrentStreamsCount];\n\n              if (!session.destroyed && !session.closed) {\n                closeSessionIfCovered(this.sessions[normalizedOptions], session);\n\n                if (isFree() && !session.closed) {\n                  if (!wasFree) {\n                    this._freeSessionsCount++;\n                    wasFree = true;\n                  }\n\n                  const isEmpty = session[kCurrentStreamsCount] === 0;\n\n                  if (isEmpty) {\n                    session.unref();\n                  }\n\n                  if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {\n                    session.close();\n                  } else {\n                    closeCoveredSessions(this.sessions[normalizedOptions], session);\n                    processListeners();\n                  }\n                }\n              }\n            });\n            return stream;\n          };\n        } catch (error) {\n          for (const listener of listeners) {\n            listener.reject(error);\n          }\n\n          removeFromQueue();\n        }\n      };\n\n      entry.listeners = listeners;\n      entry.completed = false;\n      entry.destroyed = false;\n      this.queue[normalizedOptions][normalizedOrigin] = entry;\n\n      this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n    });\n  }\n\n  request(origin, options, headers, streamOptions) {\n    return new Promise((resolve, reject) => {\n      this.getSession(origin, options, [{\n        reject,\n        resolve: session => {\n          try {\n            resolve(session.request(headers, streamOptions));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      }]);\n    });\n  }\n\n  createConnection(origin, options) {\n    return Agent.connect(origin, options);\n  }\n\n  static connect(origin, options) {\n    options.ALPNProtocols = ['h2'];\n    const port = origin.port || 443;\n    const host = origin.hostname || origin.host;\n\n    if (typeof options.servername === 'undefined') {\n      options.servername = host;\n    }\n\n    return tls.connect(port, host, options);\n  }\n\n  closeFreeSessions() {\n    for (const sessions of Object.values(this.sessions)) {\n      for (const session of sessions) {\n        if (session[kCurrentStreamsCount] === 0) {\n          session.close();\n        }\n      }\n    }\n  }\n\n  destroy(reason) {\n    for (const sessions of Object.values(this.sessions)) {\n      for (const session of sessions) {\n        session.destroy(reason);\n      }\n    }\n\n    for (const entriesOfAuthority of Object.values(this.queue)) {\n      for (const entry of Object.values(entriesOfAuthority)) {\n        entry.destroyed = true;\n      }\n    } // New requests should NOT attach to destroyed sessions\n\n\n    this.queue = {};\n  }\n\n  get freeSessions() {\n    return getSessions({\n      agent: this,\n      isFree: true\n    });\n  }\n\n  get busySessions() {\n    return getSessions({\n      agent: this,\n      isFree: false\n    });\n  }\n\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};","map":{"version":3,"names":["EventEmitter","require","tls","http2","QuickLRU","kCurrentStreamsCount","Symbol","kRequest","kOriginSet","kGracefullyClosing","nameKeys","getSortedIndex","array","value","compare","low","high","length","mid","compareSessions","a","b","remoteSettings","maxConcurrentStreams","closeCoveredSessions","where","session","coveredSession","every","origin","includes","gracefullyClose","closeSessionIfCovered","getSessions","agent","isFree","result","normalizedOptions","sessions","filtered","filter","Agent","close","constructor","timeout","maxSessions","Infinity","maxFreeSessions","maxCachedTlsSessions","queue","_freeSessionsCount","_sessionsCount","settings","enablePush","tlsSessionCache","maxSize","normalizeOrigin","url","servername","URL","hostname","normalizeOptions","options","normalized","key","_tryToCreateNewSession","normalizedOrigin","item","completed","getSession","listeners","Promise","resolve","reject","Array","isArray","undefined","TypeError","currentStreamsCount","optimalSession","sessionMaxConcurrentStreams","sessionCurrentStreamsCount","destroyed","error","Error","push","removeFromQueue","entry","Object","keys","name","receivedSettings","connect","createConnection","get","wasFree","socket","once","tlsSession","set","delete","setTimeout","destroy","splice","indexOf","code","processListeners","shift","on","originSet","ref","unref","listener","emit","request","headers","streamOptions","stream","closed","isEmpty","ALPNProtocols","port","host","closeFreeSessions","values","reason","entriesOfAuthority","freeSessions","busySessions","module","exports","globalAgent"],"sources":["C:/Users/hamzu/Desktop/React/React projects/react-store/node_modules/http2-wrapper/source/agent.js"],"sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\n\nconst nameKeys = [\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\n\t// `tls.connect()` options\n\t'localAddress',\n\t'path',\n\t'rejectUnauthorized',\n\t'minDHSize',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'clientCertEngine',\n\t'ciphers',\n\t'key',\n\t'pfx',\n\t'servername',\n\t'minVersion',\n\t'maxVersion',\n\t'secureProtocol',\n\t'crl',\n\t'honorCipherOrder',\n\t'ecdhCurve',\n\t'dhparam',\n\t'secureOptions',\n\t'sessionIdContext'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\t/* istanbul ignore next */\n\t\tif (compare(array[mid], value)) {\n\t\t\t// This never gets called because we use descending sort. Better to have this anyway.\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => {\n\treturn a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (const coveredSession of where) {\n\t\tif (\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (const session of where) {\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\nconst getSessions = ({agent, isFree}) => {\n\tconst result = {};\n\n\t// eslint-disable-next-line guard-for-in\n\tfor (const normalizedOptions in agent.sessions) {\n\t\tconst sessions = agent.sessions[normalizedOptions];\n\n\t\tconst filtered = sessions.filter(session => {\n\t\t\tconst result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\treturn isFree ? result : !result;\n\t\t});\n\n\t\tif (filtered.length !== 0) {\n\t\t\tresult[normalizedOptions] = filtered;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamsCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// A session is considered busy when its current streams count\n\t\t// is equal to or greater than the `maxConcurrentStreams` value.\n\n\t\t// A session is considered free when its current streams count\n\t\t// is less than the `maxConcurrentStreams` value.\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max free sessions in total\n\t\t// TODO: decreasing `maxFreeSessions` should close some sessions\n\t\tthis.maxFreeSessions = maxFreeSessions;\n\n\t\tthis._freeSessionsCount = 0;\n\t\tthis._sessionsCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tstatic normalizeOrigin(url, servername) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = new URL(url);\n\t\t}\n\n\t\tif (servername && url.hostname !== servername) {\n\t\t\turl.hostname = servername;\n\t\t}\n\n\t\treturn url.origin;\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tif (options) {\n\t\t\tfor (const key of nameKeys) {\n\t\t\t\tif (options[key]) {\n\t\t\t\t\tnormalized += `:${options[key]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n\t\tif (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t// The entry function can be run only once.\n\t\t// BUG: The session may be never created when:\n\t\t// - the first condition is false AND\n\t\t// - this function is never called with the same arguments in the future.\n\t\tif (this._sessionsCount < this.maxSessions && !item.completed) {\n\t\t\titem.completed = true;\n\n\t\t\titem();\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n\t\t\tif (normalizedOrigin === undefined) {\n\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\treject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||\n\t\t\t\t\t\t\tsession[kGracefullyClosing] ||\n\t\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t\tsession.destroyed\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We only need set this once.\n\t\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're looking for the session which has biggest current pending stream count,\n\t\t\t\t\t\t// in order to minimalize the amount of active sessions.\n\t\t\t\t\t\tif (sessionCurrentStreamsCount > currentStreamsCount) {\n\t\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\t/* istanbul ignore next: safety check */\n\t\t\t\t\tif (listeners.length !== 1) {\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Expected the length of listeners to be 1, got ${listeners.length}.\\n` +\n\t\t\t\t\t\t\t\t'Please report this to https://github.com/szmarczak/http2-wrapper/'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlisteners[0].resolve(optimalSession);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\n\t\t\t\t\t// This shouldn't be executed here.\n\t\t\t\t\t// See the comment inside _tryToCreateNewSession.\n\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (Object.keys(this.queue[normalizedOptions]).length === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = () => {\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst session = http2.connect(origin, {\n\t\t\t\t\t\tcreateConnection: this.createConnection,\n\t\t\t\t\t\tsettings: this.settings,\n\t\t\t\t\t\tsession: this.tlsSessionCache.get(name),\n\t\t\t\t\t\t...options\n\t\t\t\t\t});\n\t\t\t\t\tsession[kCurrentStreamsCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\t\t\t\t\tlet wasFree = true;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\t// TODO: Maybe the streams should have a \"Session timed out\" error?\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// 1. If it wasn't free then no need to decrease because\n\t\t\t\t\t\t\t//    it has been decreased already in session.request().\n\t\t\t\t\t\t\t// 2. `stream.once('close')` won't increment the count\n\t\t\t\t\t\t\t//    because the session is already closed.\n\t\t\t\t\t\t\tif (wasFree) {\n\t\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._sessionsCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\n\t\t\t\t\t\t\tif (where.length === 0) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tif (!(normalizedOptions in this.queue) || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const origin of session[kOriginSet]) {\n\t\t\t\t\t\t\tif (origin in this.queue[normalizedOptions]) {\n\t\t\t\t\t\t\t\tconst {listeners} = this.queue[normalizedOptions][origin];\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (listeners.length !== 0 && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners.shift().resolve(session);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst where = this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\tif (where[origin].listeners.length === 0) {\n\t\t\t\t\t\t\t\t\tdelete where[origin];\n\n\t\t\t\t\t\t\t\t\tif (Object.keys(where).length === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t// The session is full.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// Fix Node.js bug preventing the process from exiting\n\t\t\t\t\t\tsession.ref();\n\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\tthis._sessionsCount++;\n\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._freeSessionsCount += 1;\n\t\t\t\t\t\treceivedSettings = true;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\n\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t// TODO: Close last recently used (or least used?) session\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if we haven't managed to execute all listeners.\n\t\t\t\t\t\tif (listeners.length !== 0) {\n\t\t\t\t\t\t\t// Request for a new session with predefined listeners.\n\t\t\t\t\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\t\t\t\t\tlisteners.length = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\t++session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\twasFree = isFree();\n\n\t\t\t\t\t\t\t--session[kCurrentStreamsCount];\n\n\t\t\t\t\t\t\tif (!session.destroyed && !session.closed) {\n\t\t\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\t\t\tif (isFree() && !session.closed) {\n\t\t\t\t\t\t\t\t\tif (!wasFree) {\n\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount++;\n\n\t\t\t\t\t\t\t\t\t\twasFree = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isEmpty = session[kCurrentStreamsCount] === 0;\n\n\t\t\t\t\t\t\t\t\tif (isEmpty) {\n\t\t\t\t\t\t\t\t\t\tsession.unref();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tisEmpty &&\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount > this.maxFreeSessions ||\n\t\t\t\t\t\t\t\t\t\t\tsession[kGracefullyClosing]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(session.request(headers, streamOptions));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tcreateConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname || origin.host;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\treturn tls.connect(port, host, options);\n\t}\n\n\tcloseFreeSessions() {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tif (session[kCurrentStreamsCount] === 0) {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy(reason) {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tsession.destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\tfor (const entriesOfAuthority of Object.values(this.queue)) {\n\t\t\tfor (const entry of Object.values(entriesOfAuthority)) {\n\t\t\t\tentry.destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t}\n\n\tget freeSessions() {\n\t\treturn getSessions({agent: this, isFree: true});\n\t}\n\n\tget busySessions() {\n\t\treturn getSessions({agent: this, isFree: false});\n\t}\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}