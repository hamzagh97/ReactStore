{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst PCancelable = require(\"p-cancelable\");\n\nconst types_1 = require(\"./types\");\n\nconst parse_body_1 = require(\"./parse-body\");\n\nconst core_1 = require(\"../core\");\n\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\n\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\n\nconst is_response_ok_1 = require(\"../core/utils/is-response-ok\");\n\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\n\nfunction asPromise(normalizedOptions) {\n  let globalRequest;\n  let globalResponse;\n  const emitter = new events_1.EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const makeRequest = retryCount => {\n      const request = new core_1.default(undefined, normalizedOptions);\n      request.retryCount = retryCount;\n      request._noPipe = true;\n      onCancel(() => request.destroy());\n      onCancel.shouldReject = false;\n      onCancel(() => reject(new types_1.CancelError(request)));\n      globalRequest = request;\n      request.once('response', async response => {\n        var _a;\n\n        response.retryCount = retryCount;\n\n        if (response.request.aborted) {\n          // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n          return;\n        } // Download body\n\n\n        let rawBody;\n\n        try {\n          rawBody = await get_buffer_1.default(request);\n          response.rawBody = rawBody;\n        } catch (_b) {\n          // The same error is caught below.\n          // See request.once('error')\n          return;\n        }\n\n        if (request._isAboutToError) {\n          return;\n        } // Parse body\n\n\n        const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n        const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n        const {\n          options\n        } = request;\n\n        if (isCompressed && !options.decompress) {\n          response.body = rawBody;\n        } else {\n          try {\n            response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fallback to `utf8`\n            response.body = rawBody.toString();\n\n            if (is_response_ok_1.isResponseOk(response)) {\n              request._beforeError(error);\n\n              return;\n            }\n          }\n        }\n\n        try {\n          for (const [index, hook] of options.hooks.afterResponse.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              const typedOptions = core_1.default.normalizeArguments(undefined, { ...updatedOptions,\n                retry: {\n                  calculateDelay: () => 0\n                },\n                throwHttpErrors: false,\n                resolveBodyOnly: false\n              }, options); // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n\n              typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n\n              for (const hook of typedOptions.hooks.beforeRetry) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(typedOptions);\n              }\n\n              const promise = asPromise(typedOptions);\n              onCancel(() => {\n                promise.catch(() => {});\n                promise.cancel();\n              });\n              return promise;\n            });\n          }\n        } catch (error) {\n          request._beforeError(new types_1.RequestError(error.message, error, request));\n\n          return;\n        }\n\n        globalResponse = response;\n\n        if (!is_response_ok_1.isResponseOk(response)) {\n          request._beforeError(new types_1.HTTPError(response));\n\n          return;\n        }\n\n        resolve(request.options.resolveBodyOnly ? response.body : response);\n      });\n\n      const onError = error => {\n        if (promise.isCanceled) {\n          return;\n        }\n\n        const {\n          options\n        } = request;\n\n        if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n          const {\n            response\n          } = error;\n          resolve(request.options.resolveBodyOnly ? response.body : response);\n          return;\n        }\n\n        reject(error);\n      };\n\n      request.once('error', onError);\n      const previousBody = request.options.body;\n      request.once('retry', (newRetryCount, error) => {\n        var _a, _b;\n\n        if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n          onError(error);\n          return;\n        }\n\n        makeRequest(newRetryCount);\n      });\n      proxy_events_1.default(request, emitter, proxiedRequestEvents);\n    };\n\n    makeRequest(0);\n  });\n\n  promise.on = (event, fn) => {\n    emitter.on(event, fn);\n    return promise;\n  };\n\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      const {\n        options\n      } = globalResponse.request;\n      return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n    })();\n\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n\n  promise.json = () => {\n    const {\n      headers\n    } = globalRequest.options;\n\n    if (!globalRequest.writableFinished && headers.accept === undefined) {\n      headers.accept = 'application/json';\n    }\n\n    return shortcut('json');\n  };\n\n  promise.buffer = () => shortcut('buffer');\n\n  promise.text = () => shortcut('text');\n\n  return promise;\n}\n\nexports.default = asPromise;\n\n__exportStar(require(\"./types\"), exports);","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__exportStar","exports","p","prototype","hasOwnProperty","call","value","events_1","require","is_1","PCancelable","types_1","parse_body_1","core_1","proxy_events_1","get_buffer_1","is_response_ok_1","proxiedRequestEvents","asPromise","normalizedOptions","globalRequest","globalResponse","emitter","EventEmitter","promise","resolve","reject","onCancel","makeRequest","retryCount","request","default","_noPipe","destroy","shouldReject","CancelError","once","response","_a","aborted","rawBody","_b","_isAboutToError","contentEncoding","headers","toLowerCase","isCompressed","includes","options","decompress","body","responseType","parseJson","encoding","error","toString","isResponseOk","_beforeError","index","hook","hooks","afterResponse","entries","updatedOptions","typedOptions","normalizeArguments","retry","calculateDelay","throwHttpErrors","resolveBodyOnly","slice","beforeRetry","catch","cancel","RequestError","message","HTTPError","onError","isCanceled","previousBody","newRetryCount","nodeStream","on","event","fn","shortcut","newPromise","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"sources":["C:/Users/hamzu/Desktop/React/React projects/react-store/node_modules/got/dist/source/as-promise/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst PCancelable = require(\"p-cancelable\");\nconst types_1 = require(\"./types\");\nconst parse_body_1 = require(\"./parse-body\");\nconst core_1 = require(\"../core\");\nconst proxy_events_1 = require(\"../core/utils/proxy-events\");\nconst get_buffer_1 = require(\"../core/utils/get-buffer\");\nconst is_response_ok_1 = require(\"../core/utils/is-response-ok\");\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress'\n];\nfunction asPromise(normalizedOptions) {\n    let globalRequest;\n    let globalResponse;\n    const emitter = new events_1.EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const makeRequest = (retryCount) => {\n            const request = new core_1.default(undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            onCancel(() => request.destroy());\n            onCancel.shouldReject = false;\n            onCancel(() => reject(new types_1.CancelError(request)));\n            globalRequest = request;\n            request.once('response', async (response) => {\n                var _a;\n                response.retryCount = retryCount;\n                if (response.request.aborted) {\n                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                    return;\n                }\n                // Download body\n                let rawBody;\n                try {\n                    rawBody = await get_buffer_1.default(request);\n                    response.rawBody = rawBody;\n                }\n                catch (_b) {\n                    // The same error is caught below.\n                    // See request.once('error')\n                    return;\n                }\n                if (request._isAboutToError) {\n                    return;\n                }\n                // Parse body\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = rawBody;\n                }\n                else {\n                    try {\n                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fallback to `utf8`\n                        response.body = rawBody.toString();\n                        if (is_response_ok_1.isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            const typedOptions = core_1.default.normalizeArguments(undefined, {\n                                ...updatedOptions,\n                                retry: {\n                                    calculateDelay: () => 0\n                                },\n                                throwHttpErrors: false,\n                                resolveBodyOnly: false\n                            }, options);\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n                            for (const hook of typedOptions.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(typedOptions);\n                            }\n                            const promise = asPromise(typedOptions);\n                            onCancel(() => {\n                                promise.catch(() => { });\n                                promise.cancel();\n                            });\n                            return promise;\n                        });\n                    }\n                }\n                catch (error) {\n                    request._beforeError(new types_1.RequestError(error.message, error, request));\n                    return;\n                }\n                globalResponse = response;\n                if (!is_response_ok_1.isResponseOk(response)) {\n                    request._beforeError(new types_1.HTTPError(response));\n                    return;\n                }\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options.body;\n            request.once('retry', (newRetryCount, error) => {\n                var _a, _b;\n                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n                    onError(error);\n                    return;\n                }\n                makeRequest(newRetryCount);\n            });\n            proxy_events_1.default(request, emitter, proxiedRequestEvents);\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        const { headers } = globalRequest.options;\n        if (!globalRequest.writableFinished && headers.accept === undefined) {\n            headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports.default = asPromise;\n__exportStar(require(\"./types\"), exports);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}