{"ast":null,"code":"'use strict';\n\nconst tls = require('tls');\n\nmodule.exports = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let connect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tls.connect;\n  return new Promise((resolve, reject) => {\n    let timeout = false;\n    let socket;\n\n    const callback = async () => {\n      await socketPromise;\n      socket.off('timeout', onTimeout);\n      socket.off('error', reject);\n\n      if (options.resolveSocket) {\n        resolve({\n          alpnProtocol: socket.alpnProtocol,\n          socket,\n          timeout\n        });\n\n        if (timeout) {\n          await Promise.resolve();\n          socket.emit('timeout');\n        }\n      } else {\n        socket.destroy();\n        resolve({\n          alpnProtocol: socket.alpnProtocol,\n          timeout\n        });\n      }\n    };\n\n    const onTimeout = async () => {\n      timeout = true;\n      callback();\n    };\n\n    const socketPromise = (async () => {\n      try {\n        socket = await connect(options, callback);\n        socket.on('error', reject);\n        socket.once('timeout', onTimeout);\n      } catch (error) {\n        reject(error);\n      }\n    })();\n  });\n};","map":{"version":3,"names":["tls","require","module","exports","options","connect","Promise","resolve","reject","timeout","socket","callback","socketPromise","off","onTimeout","resolveSocket","alpnProtocol","emit","destroy","on","once","error"],"sources":["C:/Users/hamzu/Desktop/React/React projects/react-store/node_modules/resolve-alpn/index.js"],"sourcesContent":["'use strict';\nconst tls = require('tls');\n\nmodule.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {\n\tlet timeout = false;\n\n\tlet socket;\n\n\tconst callback = async () => {\n\t\tawait socketPromise;\n\n\t\tsocket.off('timeout', onTimeout);\n\t\tsocket.off('error', reject);\n\n\t\tif (options.resolveSocket) {\n\t\t\tresolve({alpnProtocol: socket.alpnProtocol, socket, timeout});\n\n\t\t\tif (timeout) {\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tsocket.emit('timeout');\n\t\t\t}\n\t\t} else {\n\t\t\tsocket.destroy();\n\t\t\tresolve({alpnProtocol: socket.alpnProtocol, timeout});\n\t\t}\n\t};\n\n\tconst onTimeout = async () => {\n\t\ttimeout = true;\n\t\tcallback();\n\t};\n\n\tconst socketPromise = (async () => {\n\t\ttry {\n\t\t\tsocket = await connect(options, callback);\n\n\t\t\tsocket.on('error', reject);\n\t\t\tsocket.once('timeout', onTimeout);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t})();\n});\n"],"mappings":"AAAA;;AACA,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAnB;;AAEAC,MAAM,CAACC,OAAP,GAAiB;EAAA,IAACC,OAAD,uEAAW,EAAX;EAAA,IAAeC,OAAf,uEAAyBL,GAAG,CAACK,OAA7B;EAAA,OAAyC,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;IAC1F,IAAIC,OAAO,GAAG,KAAd;IAEA,IAAIC,MAAJ;;IAEA,MAAMC,QAAQ,GAAG,YAAY;MAC5B,MAAMC,aAAN;MAEAF,MAAM,CAACG,GAAP,CAAW,SAAX,EAAsBC,SAAtB;MACAJ,MAAM,CAACG,GAAP,CAAW,OAAX,EAAoBL,MAApB;;MAEA,IAAIJ,OAAO,CAACW,aAAZ,EAA2B;QAC1BR,OAAO,CAAC;UAACS,YAAY,EAAEN,MAAM,CAACM,YAAtB;UAAoCN,MAApC;UAA4CD;QAA5C,CAAD,CAAP;;QAEA,IAAIA,OAAJ,EAAa;UACZ,MAAMH,OAAO,CAACC,OAAR,EAAN;UACAG,MAAM,CAACO,IAAP,CAAY,SAAZ;QACA;MACD,CAPD,MAOO;QACNP,MAAM,CAACQ,OAAP;QACAX,OAAO,CAAC;UAACS,YAAY,EAAEN,MAAM,CAACM,YAAtB;UAAoCP;QAApC,CAAD,CAAP;MACA;IACD,CAjBD;;IAmBA,MAAMK,SAAS,GAAG,YAAY;MAC7BL,OAAO,GAAG,IAAV;MACAE,QAAQ;IACR,CAHD;;IAKA,MAAMC,aAAa,GAAG,CAAC,YAAY;MAClC,IAAI;QACHF,MAAM,GAAG,MAAML,OAAO,CAACD,OAAD,EAAUO,QAAV,CAAtB;QAEAD,MAAM,CAACS,EAAP,CAAU,OAAV,EAAmBX,MAAnB;QACAE,MAAM,CAACU,IAAP,CAAY,SAAZ,EAAuBN,SAAvB;MACA,CALD,CAKE,OAAOO,KAAP,EAAc;QACfb,MAAM,CAACa,KAAD,CAAN;MACA;IACD,CATqB,GAAtB;EAUA,CAvCyD,CAAzC;AAAA,CAAjB"},"metadata":{},"sourceType":"script"}